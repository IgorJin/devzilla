class Worker {
  constructor(path) {

  }
  
  onmessage(message) {

  }
  postMessage(text) {

  }
  terminate() {

  }
}

// new (path: string); // для создания инстанса нужно передать путь до исполняемого кода,
//   // в нашем случае это всегда "./worker".
//   // Не забудьте добавить обработчик исключения, так как если достигнут лимит дронов,
//   // нужно дождаться, пока можно будет создавать новые.
//   onmessage?: (message: {data: string}) => void; // сюда нужно записать свою функцию-обработчик,
//   // чтобы принимать сообщения от дрона
//   postMessage: (text: string) => void; // эту функцию нужно вызвать для передачи строки боту,
//   // который её захеширует
//   terminate: () => void; // после одного использования, нужно удалять инстансы,
//   // таким образом освобождать дроны для следующих работ

Программа для дронов
Неверное решение
Инопланетяне попросили вас об одной услуге. Помогите им реализовать программный комплекс для управления дронами и сбора ресурсов с планет в общий транспортный корабль. Хороший проект для вашего портфолио, не правда ли?

Каждый дрон может совершить некую работу над ресурсами и преобразовать полученные данные в хэш. У вас ограниченное количество дронов, не известно, какое. Вот интерфейс нашего дрона:

interface Worker {
  new (path: string); // для создания инстанса нужно передать путь до исполняемого кода,
  // в нашем случае это всегда "./worker".
  // Не забудьте добавить обработчик исключения, так как если достигнут лимит дронов,
  // нужно дождаться, пока можно будет создавать новые.
  onmessage?: (message: {data: string}) => void; // сюда нужно записать свою функцию-обработчик,
  // чтобы принимать сообщения от дрона
  postMessage: (text: string) => void; // эту функцию нужно вызвать для передачи строки боту,
  // который её захеширует
  terminate: () => void; // после одного использования, нужно удалять инстансы,
  // таким образом освобождать дроны для следующих работ
}
Итак, для начала вам нужно организовать некую очередь по работе с дронами. Работа с одним может выглядеть вот так:

const Worker = require(’./WorkerClass’);

const doOneWork = (text: string) => {
  try {
    const worker = new Worker('./worker'); // создаём дрона
    worker.onmessage = ({data}) => { // подписываемся на его сообщение
      // тут работа выполнена, используем data и освобождаем дрон
      worker.terminate();
    };
    worker.postMessage(text); // отправляем сообщение дрону, чтобы он начал работу
  } catch (e) {
    // свободных дронов нету, ждём освобождения дронов и создаём новый дрон повторно
  }
};
Работа с ресурсами.

Необходимо преобразовать результаты работы дронов к одному хешу. На вход вашей функции передаётся массив строк, где записаны совершённые действия. Нужно с помощью дронов каждую строку преобразовать в хеш. Далее результаты попарно конкатенировать в порядке расположения в массиве. Если количество элементов нечётное, последний конкатенируем со своей копией. Над новыми строками повторяем предыдущий шаг, пока не останется одного хеша. Наглядную схему алгоритма можно скачать по ссылке внизу условия задачи.

Если во входных данных пустой массив, то нужно вернуть "0" (строкой)

Формат ввода
На вход подается массив строк с данными. Данные могут быть произвольными

[
  "Dron1 found 14 resources",
  "Dron2 found 12 resources",
  "Dron3 found nothing",
  "Dron3 found nothing (2 time)",
  "Dron3 found nothing (3 time)",
  "Dron3 found 5 resources",
  "Dron2 sent 5 resources to Dron3",
  "Dron1 found 10 resources",
  "Dron3 found 3 resources"
]
Формат вывода
Ваша функция должна возвращать Promise, который резолвит результат строкой, например:

"1c3b9ab092af32cae6f474fb68f22b91adcf6537be4a2619bd32f92d82930534"

Примечание
В форматах ввода и вывода приведены реальные данные первого теста. Файл с решением требуется оформить по шаблону:

const Worker = require('./WorkerClass');

module.exports = (input) => new Promise((resolve) => { ... resolve(result) ... }
Не допускается использование минифицированного кода в решениях. Организаторы оставляют за собой право принимать решение о результатах соревнования на основе экспертной оценки исходного кода участников.

Наглядная схема вычисления хэша: